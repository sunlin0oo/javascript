<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。列表中的每个元素只可能是整数或整数嵌套列表*/
        // var deserialize = function(s) {
        //     let index = 0;
        //     const dfs = (s) => {
        //         if (s[index] === '[') {
        //             index++;
        //             const ni = new NestedInteger();
        //             while (s[index] !== ']') {
        //                 ni.add(dfs(s));
        //                 if (s[index] === ',') {
        //                     index++;
        //                 }
        //             }
        //             index++;
        //             return ni;
        //         } else {
        //             let negative = false;
        //             if (s[index] === '-') {
        //                 negative = true;
        //                 index++;
        //             }
        //             let num = 0;
        //             while (index < s.length && isDigit(s[index])) {
        //             //charCodeAt() 方法可返回指定位置的字符的 Unicode 编码
        //                 num = num * 10 + s[index].charCodeAt() - '0'.charCodeAt();
        //                 index++;
        //             }
        //             if (negative) {
        //                 num *= -1;
        //             }
        //             return new NestedInteger(num);
        //         }
        //     }
        //     return dfs(s);
        // };

        // const isDigit = (ch) => {
        //     //parseFloat(ch)该函数指定字符串中的首个字符是否是数字--->如果字符串的第一个字符不能被转换为数字，那么 parseFloat() 会返回 NaN。
        //     return parseFloat(ch).toString() === "NaN" ? false : true;
        // }


        /*给定一个整数 n ，返回 *可表示为两个 `n` 位整数乘积的 **最大回文整数*** 。因为答案可能非常大，所以返回它对 `1337` **取余** 。*/
        // var largestPalindrome = function(n) {
        //     if(n === 1){
        //         return 9
        //     };
        //     let max = 10**n - 1;
        //     for(let left = max ; left>max/10; left--){
        //         let right = String(left).split('').reverse().join('');
        //         let p = BigInt(String(left)+right);
        //         let x = BigInt(max);
        //         while((x*x)>=p){
        //             if(p % x === BigInt(0)){
        //                 return p % BigInt(1337);
        //             }
        //             x--;
        //         }
        //     }
        // };


        // const isletter= (i)=>{
        //     return(i >= "a" && i<="z") || (i >= "A" && i<="Z");
        // }

        // var mostCommonWord = function(paragraph, banned) {
        //     const bannedSet = new Set();
        //     //将禁用单词放入Set集合中
        //     for (const word of banned) {
        //         bannedSet.add(word);
        //     }

        //     let maxFrequency = 0;//记录当前最大次序
        //     const frequencies = new Map();//建立HashMap
        //     let sb = '';
        //     const length = paragraph.length;//不计算分号
        //     for(let i = 0;i <= length;i++){
        //         if(i<length && isletter(paragraph[i])){
        //             sb = sb + paragraph[i].toLowerCase();//拼接单词
        //         }else if(sb.length >0){//判断之前的单词是否拼接，避免""," 和 " "连续出现情况
        //             if(!bannedSet.has(sb)){ //一个单词判断是否为禁用单词
        //                 let frequency = (frequencies.get(sb) || 0) + 1;//哈希表加入，若没有则输入，有的话则value+1,
        //                 frequencies.set(sb, frequency);//重新计数，加入哈希表中
        //                 maxFrequency = Math.max(maxFrequency,frequency);//求出当前最多的选中次序
        //             }
        //             sb = '';//重置单词
        //         }
        //     }
        //     let  mostCommon = '';
        //     // entries() 返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。
        //     for (const [word,frequency] of frequencies.entries()){
        //         if (frequency === maxFrequency) { //与之前的最多选中进行匹配key
        //             mostCommon = word;
        //             break;
        //         }
        //     }
        //     console.log(mostCommon);
        //     return  mostCommon;
        // };

        /*给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标   */
        // var twoSum = function(nums, target) {
        //     let map = new Map();
        //     for(let i = 0,len = nums.length;i<len ; i++){
        //         if(map.has(target - nums[i])){
        //             return [map.get(target - nums[i]),i]
        //         }else{
        //             map.set(nums[i],i);
        //         }
        //     }
        //     return null;
        // };

        /*给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
        请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。*/

        // var merge = function(nums1, m, nums2, n) {
        //     let p1=0,p2=0;
        //     let sort =new Array(m+n).fill(0);
        //     var cur;
        //     while(p1 < m || p2 <n){
        //         if(p1 === m){
        //             cur = nums2[p2];
        //             p2++;
        //         }else if(p2 === n){
        //             cur = nums1[p1];
        //             p1++;
        //         }else if(nums1[p1]<=nums2[p2]){
        //             cur = nums1[p1];
        //             p1++;
        //         }else {
        //             cur = nums2[p2];
        //             p2++;
        //         }
        //         sort[p1 + p2 - 1] = cur;
        //     }
        //     for(let i = 0 ; i<m+n;i++){
        //         nums1[i] = sort[i];
        //     }
        // };

        /*给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。
        返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。*/

        // var intersect = function(nums1, nums2) {
        //     let intersectArray = new Map();
        //     let arr1 = [];
        //     let len1 =nums1.length,len2 =nums2.length;
        //     for(let i = 0;i<len1;i++){
        //         if(!intersectArray.get(nums1[i])){
        //             intersectArray.set(nums1[i],1)
        //         }else{
        //             let nums = intersectArray.get(nums1[i]) + 1;
        //             intersectArray.set(nums1[i],nums);
        //         }
        //     }
        //     for(let i = 0;i < len2;i++){
        //         if(intersectArray.get(nums2[i])>0){
        //             let nums = intersectArray.get(nums2[i]) - 1;
        //             intersectArray.set(nums2[i],nums);
        //             arr1.push(nums2[i]);
        //         }
        //     }
        //     return arr1;
        // };

        /*给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
        你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
         返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
         */

        // var maxProfit = function(prices) {
        //     let minprice = prices[0], maxmoney = -prices[0];
        //     let index = 0
        //     for(let i = 0,len = prices.length;i<len;i++){
        //         if(prices[i] - minprice > maxmoney){
        //             maxmoney = prices[i] - minprice;
        //             index = i+1;
        //         };
        //         if(prices[i] < minprice){
        //             minprice = prices[i];
        //         };
        //     };
        //     if(maxmoney<=0){
        //         return 0;
        //     }
        //     return maxmoney;
        // };


        /**在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。
            给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。
            重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。
            如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。*/

        // var matrixReshape = function(mat, r, c) {
        //     let m = mat.length;
        //     let n = mat[0].length;
        //     if((m * n) !== (r*c)) return mat;
        //     let reshapeArr = [];
        //     let arr =[];
        //     arr = mat.flat(1);
        //     let index = 0
        //     for(let i = 0;i<r;i++){
        //         let arr1 = []
        //         for(let j=0;j<c;j++){
        //             arr1.push(arr[index]);
        //             index++;
        //         }
        //         reshapeArr.push(arr1);
        //     }
        //     return reshapeArr;
        // };


        /**给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。在「杨辉三角」中，每个数是它左上方和右上方的数的和。*/
        // var generate = function(numRows) {
        //     let all = [];
        //     for(let i = 0;i<numRows;i++){
        //         let nowRow = new Array(i+1).fill(1);
        //         for(let j = 1 ;j < nowRow.length-1;j++){
        //             nowRow[j] = all[i-1][j-1] + all[i-1][j];
        //         }
        //         all.push(nowRow);
        //     }
        //     return all;
        // };

        /**给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。
         * 返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。
         * 两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。
         *
        */

        // var shortestToChar = function(s, c) {
        //     console.log(subboxes);
        //     let arr = Array.from(s);
        //     let answer = [];
        //     let answerIndex = [];
        //     for(let i = 0,len = arr.length;i<len;i++){
        //         if(arr[i] === c){
        //             answerIndex.push(i);
        //         }
        //     }
        //     for(let i = 0,len = answerIndex.length;i<len;i++){
        //         for(let j = 0,len = answerIndex[i] ;j<=len;j++){
        //             if(answerIndex[i-1] === undefined){
        //                 answer.push( Math.abs(answerIndex[i] - j));
        //             }else if(j >answerIndex[i-1]){
        //                 answer.push(Math.min( Math.abs(answerIndex[i] - j),Math.abs(answerIndex[i-1] - j)));
        //             }
        //             else{
        //                 continue;
        //             }
        //         }
        //     }
        //     if(answerIndex[answerIndex.length-1] < arr.length){
        //         for(let i = answerIndex[answerIndex.length-1]+1,len = arr.length;i<len;i++){
        //             answer.push( Math.abs(answerIndex[answerIndex.length-1] - i));
        //         }
        //     }
        //     return answer;
        // };

        /**请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
        数字 1-9 在每一行只能出现一次。
        数字 1-9 在每一列只能出现一次。
        数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。----->可以采用坐标的方法
        */


        // var isValidSudoku = function(board) {
        //     for(let i = 0;i<9;i++){
        //         let map1 = new Map();
        //         let map2 = new Map();
        //         for(let j = 0;j<9;j++){
        //             if(board[i][j]!=='.'){
        //                 if(map1.has(board[i][j])) return false;
        //                 map1.set(board[i][j],[i][j]);
        //             };
        //             if(board[j][i]!=='.'){
        //                 if(map2.has(board[j][i])) return false;
        //                 map2.set(board[j][i],[j][i]);
        //             };
        //         };
        //     };
        //     for(let i = 0;i<9;i+=3){
        //         let map3 = new Map();
        //         for(let j = 0;j<9;j++){
        //             if(Math.floor(j%3) === 0){
        //                 map3 = new Map();
        //             };
        //             if(board[i][j]!=='.'){
        //                 if(map3.has(board[i][j])) return false;
        //                 map3.set(board[i][j]);
        //             }
        //             if(board[i+1][j]!=='.'){
        //                 if(map3.has(board[i+1][j])) return false;
        //                 map3.set(board[i+1][j]);
        //             }
        //             if(board[i+2][j]!=='.'){
        //                 if(map3.has(board[i+2][j])) return false;
        //                 map3.set(board[i+2][j]);
        //             }
        //         }
        //     };
        //     return true;
        // };

        // var isValidSudoku = function(board) {
        //     const rows = new Array(9).fill(0).map(() => new Array(9).fill(0));
        //     const columns = new Array(9).fill(0).map(() => new Array(9).fill(0));
        //     const subboxes = new Array(3).fill(0).map(() => new Array(3).fill(0).map(() => new Array(9).fill(0)));
        //     for (let i = 0; i < 9; i++) {
        //         for (let j = 0; j < 9; j++) {
        //             const c = board[i][j];
        //             if (c !== '.') {
        //c.charCodeAt() - '0'.charCodeAt() ===Number(c)  ===> s[i]的unicode编码，减去0的unicode编码，来获取s[i]的数字s
        //                 const index = c.charCodeAt() - '0'.charCodeAt() - 1;
        //                 rows[i][index]++;
        //                 columns[j][index]++;
        //                 subboxes[Math.floor(i / 3)][Math.floor(j / 3)][index]++;
        //                 if (rows[i][index] > 1 || columns[j][index] > 1 || subboxes[Math.floor(i / 3)][Math.floor(j / 3)][index] > 1) {
        //                     return false;
        //                 }
        //             }
        //         }
        //     }
        //     return true;
        // };

        //给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
        // var setZeroes = function(matrix) {
        //     let row = new Map();
        //     let column = new Map();
        //     for(let i = 0,len = matrix.length;i<len;i++){
        //         for(let j = 0,len = matrix[i].length;j<len;j++){
        //             if(matrix[i][j] === 0){
        //                 if(!row.has[i])
        //                 row.set([i],0);
        //                 if(!column.has[j])
        //                 column.set([j],0);
        //             }
        //         }
        //     }
        //     console.log(row,column);
        //     for(let rows of row.keys()){
        //         for(let j = 0,len = matrix[rows].length;j<len;j++){
        //             matrix[rows][j] = 0;
        //         }
        //     }
        //     for(let i = 0,len = matrix.length;i<len;i++){
        //         for(let columns of column.keys()){
        //                 matrix[i][columns] = 0;
        //             }
        //         }

        //     return matrix
        // };

        // var setZeroes = function(matrix) {
        //     const m = matrix.length, n = matrix[0].length;
        //     const row = new Array(m).fill(false);
        //     const col = new Array(n).fill(false);
        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (matrix[i][j] === 0) {
        //                 row[i] = col[j] = true;
        //             }
        //         }
        //     }
        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (row[i] || col[j]) {
        //                 matrix[i][j] = 0;
        //             }
        //         }
        //     }
        // };

            /**
             * 给你一个由若干单词组成的句子sentence ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。
             * 请你将句子转换为 “山羊拉丁文（Goat Latin）”（一种类似于 猪拉丁文- Pig Latin 的虚构语言）。山羊拉丁文的规则如下：
             * 如果单词以元音开头（'a', 'e', 'i', 'o', 'u'），在单词后添加"ma"。
             * 例如，单词 "apple" 变为 "applema" 。
             * 如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加"ma"。
             * 例如，单词 "goat" 变为 "oatgma" 。
             * 根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从 1 开始。
             * 例如，在第一个单词后添加 "a" ，在第二个单词后添加 "aa" ，以此类推。
             * 返回将 sentence 转换为山羊拉丁文后的句子。
        */

        // var toGoatLatin = function(sentence) {
        //         const vowels = new Set();
        //         vowels.add('a');
        //         vowels.add('e');
        //         vowels.add('i');
        //         vowels.add('o');
        //         vowels.add('u');
        //         vowels.add('A');
        //         vowels.add('E');
        //         vowels.add('I');
        //         vowels.add('O');
        //         vowels.add('U');

        //         const n = sentence.length;
        //         let i = 0, cnt = 1;
        //         ans = '';

        //         while (i < n) {
        //             let j = i;
        //             while (j < n && sentence[j] !== ' ') {
        //                 ++j;
        //             }

        //             ++cnt;
        //             if (cnt !== 2) {
        //                 ans += ' ';
        //             }
        //             if (vowels.has(sentence[i])) {
        //                 ans += sentence.substring(i, j);
        //             } else {
        //                 ans += sentence.slice(i + 1, j);
        //                 ans += sentence[i];
        //             }
        //             ans += 'm';
        //             for (let k = 0; k < cnt; ++k) {
        //                 ans += 'a';
        //             }

        //             i = j + 1;
        //         }

        //         return ans;
        //     };
        /**
         * 给定一个长度为 n 的整数数组 nums 。
            假设 arrk 是数组 nums 顺时针旋转 k 个位置后的数组，我们定义 nums 的 旋转函数  F 为：
            F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]
            返回 F(0), F(1), ..., F(n-1)中的最大值 。
            生成的测试用例让答案符合 32 位 整数。

        */

        // var maxRotateFunction = function(nums) {
        //     let numSum = 0;
        //     let maxSum = 0;
        //     let temp;
        //     let len = nums.length;
        //     for(let i = 0;i<len;i++){
        //     numSum +=nums[i];
        //     }
        //     for(let i = 0;i<len;i++){
        //     maxSum += nums[i] * i;
        //     }
        //     temp = maxSum;
        //     for(let i = nums.length - 1;i>0;i--){
        //         temp = temp + numSum - len * nums[i];
        //         maxSum = Math.max(temp,maxSum);
        //     }
        //     return maxSum;
        // };

        //给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。
        // var firstUniqChar = function(s) {
        //     let map = new Map();
        //     let arr = Array.from(s);
        //     let temp = Infinity;
        //     for(let i = 0, len = arr.length;i < len ; i++){
        //         if(map.has(arr[i])){
        //             map.set(arr[i],-1);
        //         }else{
        //             map.set(arr[i],i);
        //         }
        //     }
        //     for(let value of map.values()){
        //         if(value !== -1) temp = Math.min(value,temp);
        //     }
        //     if(temp === Infinity){
        //     return -1;
        //     }else{
        //         return temp;
        //     }
        // };

        // var firstUniqChar = function(s) {
        //     /*_.countBy(collection, [iteratee=_.identity])：
        //     _.countBy方法创建一个由键组成的对象，这些键是通过运行iteratee的collection的每个元素的结果生成的。每个 key 的对应值是iteratee返回 key 的次数。
        //     */
        //     const frequency = _.countBy(s);//安装库lodash才能使用
        //     console.log(frequency);
        //     for (const [i, ch] of Array.from(s).entries()) {
        //         if (frequency[ch] === 1) {
        //             return i;
        //         }
        //     }
        //     return -1;
        // };

        /**给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。*/

        // var isAnagram = function(s, t) {
        //     if (s.length !== t.length) {
        //         return false;
        //     }
        //     const table = new Array(26).fill(0);
        //     for (let i = 0; i < s.length; ++i) {
        //         /**ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。
        //          * 'a'.codePointAt(0)
        //         */
        //         console.log("'a'.codePointAt(0)::",'a'.codePointAt(0))//97
        //         table[s.codePointAt(i) - 'a'.codePointAt(0)]++;
        //     }
        //     for (let i = 0; i < t.length; ++i) {
        //         table[t.codePointAt(i) - 'a'.codePointAt(0)]--;
        //         if (table[t.codePointAt(i) - 'a'.codePointAt(0)] < 0) {
        //             return false;
        //         }
        //     }
        //     return true;
        // };

        
        /**给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
         * 如果可以，返回 true ；否则返回 false 。magazine 中的每个字符只能在 ransomNote 中使用一次。*/
        // var canConstruct = function(ransomNote, magazine) {
        //     const table = new Array(26).fill(0);
        //     for(let i = 0,len = ransomNote.length;i<len ;i++){
        //         table[ransomNote.codePointAt(i)-'a'.codePointAt(0)]++
        //     }
        //     for(let i = 0,len = magazine.length;i<len ;i++){
        //         if(table[magazine.codePointAt(i)-'a'.codePointAt(0)] === 0){
        //             continue;
        //         }else{
        //             table[magazine.codePointAt(i)-'a'.codePointAt(0)]--;
        //         }
        //     }
        //     for(let i = 0,len = table.length;i<len ; i++){
        //         if(table[i]>0) return false;
        //     }
        //     return true;
        // };

        /**给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。
        如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，"1001" 中的两个 1 的距离为 3 。*/

        // var binaryGap = function(n) {
        //     let number = Array.from(n.toString(2));
        //     console.log(number);
        //     let firstIndex,secondIndex;
        //     for(let i = 0,len = number.length;i<len;i++){
        //         if(number[i] === '1'){
        //         firstIndex = i;
        //         break;
        //         }
        //     }
        //     for(let i = firstIndex+1,len = number.length;i<len;i++){
        //         if(number[i] === '1'){
        //             secondIndex = i;
        //             break;
        //         }
        //     }
        //     if(secondIndex === undefined) return 0;

        //     let absLength;
        //     let maxLength  = secondIndex -firstIndex ;

        //     for(let i = secondIndex+1,len = number.length;i<len;i++){
        //         if(number[i] === '1'){
        //             firstIndex = secondIndex;
        //             secondIndex = i;
        //             absLength = secondIndex - firstIndex;
        //             maxLength = Math.max(maxLength,absLength);
        //         }
        //     }
        //     return maxLength;
        // };

        // 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
        // var mergeTwoLists = function(l1, l2) {
        //     if (l1 === null) {
        //         console.log(l2);
        //         return l2;
        //     } else if (l2 === null) {
        //         console.log(l1);
        //         return l1;
        //     } else if (l1.val < l2.val) { //l1当前值大于l2当前值      
        //         l1.next = mergeTwoLists(l1.next, l2);
        //         console.log(l1);
        //         return l1;
        //     } else {
        //         l2.next = mergeTwoLists(l1, l2.next);
        //         console.log(l2);
        //         return l2;
        //     }
        // };


        /**给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。*/
        // var Solution = function(nums) {
        //     this.pos = new Map();
        //     for(let i = 0,len = nums.length;i<len;i++){
        //         if(!this.pos.has(nums[i])) this.pos.set(nums[i],[]);
        //         this.pos.get(nums[i]).push(i);
        //     }
        // };

        // Solution.prototype.pick = function(target) {
        //     const indeies = this.pos.get(target);
        //     return indeies[Math.floor(Math.random() * indeies .length)];
        // };
        
        /**给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。*/
        // function ListNode(val, next) {
        //     this.val = (val===undefined ? 0 : val)
        //     this.next = (next===undefined ? null : next)
        // }

        // var removeElements = function(head, val) {
        //     if(head === null){
        //         return head;
        //     }
        //     head.next = removeElements(head.next,val);
        //     return head.val === val? head.next : head;
        // };

        /**给你一个可能含有 重复元素 的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组中。实现 Solution 类：
            Solution(int[] nums) 用数组 nums 初始化对象。
            int pick(int target) 从 nums 中选出一个满足 nums[i] == target 的随机索引 i 。如果存在多个有效的索引，则每个索引的返回概率应当相等。*/
        /**
         * @param {number[]} nums
         */
        // var Solution = function(nums) {
        //     this.pos = new Map();
        //     for(let i = 0,len = nums.length;i<len;i++){
        //         if(!this.pos.has(nums[i])) this.pos.set(nums[i],[]);
        //         this.pos.get(nums[i]).push(i);
        //     }
        // };

        // /** 
        //  * @param {number} target
        //  * @return {number}
        //  */
        // Solution.prototype.pick = function(target) {
        //     const indeies = this.pos.get(target);
        //     return indeies[Math.floor(Math.random() * indeies .length)];
        // };

        // /**
        //  * Your Solution object will be instantiated and called as such:
        //  * var obj = new Solution(nums)
        //  * var param_1 = obj.pick(target)
        //  */


        /**给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。*/
        // var reverseList = function(head) {
        //     let curr = head;
        //     let prev = null;
        //     while(curr){
        //         let next = curr.next;
        //         curr.next = prev;
        //         prev = curr;
        //         curr = next;
        //     }
        //     return prev;
        // };
        /**给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 */
        // var deleteDuplicates = function(head) {
        //     if(!head) return head;
        //     let curr = head;
        //     console.log(curr);
        //     while(curr.next){
        //         if(curr.val === curr.next.val){
        //             curr.next = curr.next.next;
        //         }else{
        //             curr = curr.next;
        //         }
        //         console.log(head);
        //     }
        //     return head;
        // };


        // 给你一个整数数组 nums，将 nums 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。==>优化方法：原地交换/双指针+一次遍历
        // var sortArrayByParity = function(nums) {
        //     // nums.sort((a,b)=>a-b);
        //     let array1 = [];
        //     let array2 = [];
        //     for(let i = 0,len = nums.length; i < len ;i++){
        //         if(nums[i] % 2 !==0){
        //         array1.push(nums[i])
        //         }else{
        //             array2.push(nums[i])
        //         }
        //     }
        //     array2.push.apply(array2,array1);
        //     return array2
        // };

      /**给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
        有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。*/
        // var isValid = function(s) {
        //     const n = s.length;
        //     if(n%2 === 1){
        //         return false
        //     }
        //     const pairs = new Map([
        //         [')', '('],
        //         [']', '['],
        //         ['}', '{']
        //     ]);
        //     const stk = [];
        //     for(let ch of s){
        //         if(pairs.has(ch)){
        //             if(!stk.length || stk[stk.length-1] !== pairs.get(ch)){
        //                 return false;
        //             }
        //             stk.pop();
        //         }else{
        //             stk.push(ch);
        //         };
        //     };
        //     return !stk.length;
        // };

        /**请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
            实现 MyQueue 类：
            void push(int x) 将元素 x 推到队列的末尾
            int pop() 从队列的开头移除并返回元素
            int peek() 返回队列开头的元素
            boolean empty() 如果队列为空，返回 true ；否则，返回 false*/

    //         var MyQueue = function() {
    //     this.inStack = [];
    //     this.outStack = [];
    // };

    // MyQueue.prototype.push = function(x) {
    //     this.inStack.push(x);
    // };

    // /**
    //  * @return {number}
    //  */
    // MyQueue.prototype.pop = function() {
    //     if(!this.outStack.length) this.in2out();
    //     return this.outStack.pop();
    // };

    // /**
    //  * @return {number}
    //  */
    // MyQueue.prototype.peek = function() {
    //     if(!this.outStack.length) this.in2out();
    //     return this.outStack[this.outStack.length - 1];
    // };

    // /**
    //  * @return {boolean}
    //  */
    // MyQueue.prototype.empty = function() {
    //     return this.outStack.length === 0 && this.inStack.length
    // };

    // MyQueue.prototype.in2out = function(){
    //     while(this.inStack.length) this.outStack.push(this.inStack.pop());
    // }

   
    //先序二叉树
    // var preorderTraversal = function(root) {
    //     var tree = new TreeNode(1,2,3);
    //     let result = [];
    //     function preorder(node){
    //         if (node === null) return
    //         result.push(tree.val);
    //         preorder(tree.left);
    //         preorder(tree.right);
    //     }
    //     preorder(root);
    //     return result;
    // };


    /**给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。广度优先遍历*/
    // var levelOrder = function(root) {
    //     const ret = [];
    //     if (!root) {
    //         return ret;
    //     }
    //     const q = [];
    //     q.push(root);
    //     while (q.length !== 0) {
    //         const currentLevelSize = q.length;//记录节点数量
    //         ret.push([]);
    //         for (let i = 1; i <= currentLevelSize; ++i) {
    //             const node = q.shift();//出队列操作
    //             ret[ret.length - 1].push(node.val);
    //             if (node.left) q.push(node.left);//左树进队列操作
    //             if (node.right) q.push(node.right);//右树进队列操作
    //         }
    //     }
    //     return ret;
    // };

    /**给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。深度优先遍历*/
    //     var maxDepth = function(root) {
    //     if (root === null) return 0
    //     let left = maxDepth(root.left)
    //     let right = maxDepth(root.right)
    //     return Math.max(left, right) + 1
    // };

    /**给你一个二叉树的根节点 root ， 检查它是否轴对称。*/
    // var isSymmetric = function(root) {
    //     if(!root) return false;
    //     const isMirror = (l,r)=>{//分左右子树
    //         if(!l && !r) return true;//判断当前根节点的左右子树是否为空
    //         if(l && r && l.val === r.val && isMirror(l.left,r.right) && isMirror(l.right,r.left)){
    //             return true;
    //         }
    //         return false;
    //     }
    //     return isMirror(root.left,root.right);
    // };

    //给你 root1 和 root2 这两棵二叉搜索树。请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。
    // var getAllElements = function(root1, root2) {
    //     //创建两个存储树节点的数组
    //     const nums1 = [];
    //     const nums2 = [];

    //     const inorder = (node, res) => {
    //     if (node) {
    //             inorder(node.left, res);
    //             res.push(node.val);
    //             inorder(node.right, res);
    //         }
    //     };

    //     inorder(root1, nums1);
    //     inorder(root2, nums2);

    //     const merged = [];
    //     let p1 = 0, p2 = 0;
    //     //双指针归并排序
    //     while (true) {
    //         if (p1 === nums1.length) {
    //             for (let i = p2; i < nums2.length; i++) {
    //                 merged.push(nums2[i]);
    //             }
    //             break;
    //         }
    //         if (p2 === nums2.length) {
    //             for (let i = p1; i < nums1.length;i++) {
    //                 merged.push(nums1[i]);
    //             }
    //             break;
    //         }
    //         if (nums1[p1] < nums2[p2]) {
    //             merged.push(nums1[p1++]);
    //         } else {
    //             merged.push(nums2[p2++]);
    //         }
    //     }
    //     return merged;
    // }

    //给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。==>递归
    // var invertTree = function(root) {
    //     if(!root) return null;
    //     let left = invertTree(root.left);
    //     let right = invertTree(root.right);
    //     root.left = right;
    //     root.right = left;
    //     return root;
    // };
    
    /**给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，
    这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。叶子节点 是指没有子节点的节点。===>深度优先遍历*/
    // var hasPathSum = function(root, targetSum) {
    //     if(!root) return false;
    //     let res = false;
    //     var dfs = function(node,sum){
    //     if(sum === targetSum && !node.left && !node.right){
    //         res =  true; return
    //     }
    //     if(node.left)  dfs(node.left,sum+node.left.val);
    //     if(node.right) dfs(node.right,sum+node.right.val);
    // }
    //     dfs(root,root.val);
    //     return res;
    // };


    /**给定二叉搜索树（BST）的根节点 root 和一个整数值 val。你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。
     * 注意二叉树搜索性质：：：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 
    */
    // var searchBST = function(root, val) {
    //     while (root) {
    //         if (val === root.val) {
    //             return root;
    //         }
    //         root = val < root.val ? root.left : root.right;
    //     }
    //     return null;
    // };
    /**给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。
     * 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。
     * 根据性质，先分左右，直到找到空才添加 */
    // var insertIntoBST = function(root, val) {
    //     if(root === null) return new TreeNode(val);//重新创建一颗树
    //     let pos = root;
    //     while(pos!==null){
    //         if(val < pos.val){ //左
    //             if(pos.left === null){
    //                 pos.left = new TreeNode(val);
    //                 break;
    //             }else{
    //                 pos = pos.left;
    //             }
    //         }else{//右
    //             if(pos.right === null){
    //                 pos.right = new TreeNode(val);
    //                 break;
    //             }else{
    //                 pos = pos.right;
    //             }

    //         }
    //     }
    //     return root;
    // };


    /**给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。有效 二叉搜索树定义如下：
        节点的左子树只包含 小于 当前节点的数。
        节点的右子树只包含 大于 当前节点的数。
        所有左子树和右子树自身必须也是二叉搜索树。
        中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。
    */
    // var isValidBST = function(root) {
    //     let stack = [];
    //     let inorder = -Infinity;

    //     while (stack.length || root !== null) {
    //         //如果有左子树，则会遍历到底
    //         while (root !== null) {
    //             stack.push(root);
    //             root = root.left;
    //         }
    //         root = stack.pop();
    //         // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
    //         if (root.val <= inorder) {
    //             return false;
    //         }
    //         inorder = root.val;
    //         root = root.right;
    //     }
    //     return true;
    // };
    
    /**给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目==>双指针，滑动窗口
     * 一段乘积小于k的子数组中，所有的子数组都满足答案。仅统计右指针的左指针范围是因为其他子数组已经在前面计算过了。
     * 以每个数字为右边界所形成的有效子数组的个数
    */    
    // var numSubarrayProductLessThanK = function(nums, k) {
    //     if(k === 0){
    //         return 0;
    //     }
    //     let ans = 0 , left = 0,cur = 1;
    //     // left :左边界 right:右边界
    //     for(let right = 0,len = nums.length;right <len;right++){
    //         //计算滑动窗口内的所有元素乘积
    //         cur *=nums[right];
    //         /** 如果不满足条件，缩小窗口，窗口右边不动，左边右移，
    //         然后重新计算窗口是否满足条件，如果不满足，窗口左边
    //         继续右移……直到窗口内的元素满足条件，或者窗口为空为止*/
    //         while(left <= right && cur >= k){
    //             // 窗口左边右移
    //             cur /=nums[left++];
    //         }
    //         // 结尾的子数组有right - left + 1个
    //         ans +=right - left +1
    //     }
    //     return ans;
    // };

    /**写一个 RecentCounter 类来计算特定时间范围内最近的请求。
    请你实现 RecentCounter 类：
    RecentCounter() 初始化计数器，请求数为 0 。
    int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。
    保证 每次对 ping 的调用都使用比之前更大的 t 值。*/

    // var RecentCounter = function() {
    //     this.quene = []
    // };

    // /** 
    //  * @param {number} t
    //  * @return {number}
    //  */
    // RecentCounter.prototype.ping = function(t) {
    //     this.quene.push(t)
    //     console.log(JSON.stringify(this.quene));
    //     while(this.quene[0] < (t-3000)){
    //         this.quene.shift()
    //     }
    //     console.log("shift后",JSON.stringify(this.quene));
    //     return this.quene.length
    // }; 

    
       /**  给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
       任何数和 00 做异或运算，结果仍然是原来的数，即 a ⊕ 0=a。
       任何数和其自身做异或运算，结果是 00，即 a ⊕ a=0 。
       异或运算满足交换律和结合律，即 a ⊕ b ⊕ a=b ⊕ a ⊕ a=b ⊕ (a ⊕ a)=b⊕0=b

     * @param {number[]} nums
     * @return {number}
     */
    // var singleNumber = function(nums) {
    //     let ans = 0;
    //     for(const num of nums) {
    //         ans ^= num; // 异或运算
    //     }
    //     return ans;
    // };

    /**给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
       你可以假设数组是非空的，并且给定的数组总是存在多数元素。*/
    // var majorityElement = function(nums) {
    //     let halfLen = nums.length / 2;
    //     let len = nums.length;
    //     let number = new Map();
    //     for(let i = 0;i<len;i++){
    //         if(!number.has(nums[i])){
    //             number.set(nums[i],1)
    //             if(number.get(nums[i]) > halfLen) return nums[i]
    //         }else{
    //             let frequencies = number.get(nums[i]) + 1;
    //             if(frequencies > halfLen) return nums[i]
    //             number.set(nums[i],frequencies);
    //         }
    //     }
    // };


/**给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
 * 先排序，再双指针。
*/
    // var threeSum = function(nums) {
    //     let all =[]
    //     if (nums.length < 3 || !nums) return [];
    //     nums.sort((a,b)=>a-b);//排序
    //     console.log(nums);
    //     for(let i = 0,len = nums.length - 2; i<len ;i++){
    //         if(nums[i]>0) break;
    //         if(i>0 && nums[i] === nums[i-1]) continue;//去重
               //双指针
    //         let left = i + 1;
    //         let right = nums.length - 1;
    //         console.log("left",left)
    //         console.log("right",right);
    
    //         while(left < right){
    //             const sum = nums[i] + nums[left] + nums[right]
    //             if(sum === 0) {
    //                     let temp = [];
    //                     temp.push(nums[i] , nums[left] , nums[right]);
    //                     while(left < right && nums[right - 1] === nums[right]) right--;//去重
    //                     while(left < right && nums[left + 1] === nums[left]) left++;//去重
    //                     console.log(temp);
    //                     all.push(temp);
    //                     console.log(all);
    //                     right --;
    //                     left ++;
    //             }else if(sum > 0){
    //                 right --;
    //                 console.log("遍历中right",right)
    //             }else if (sum < 0){
    //                 left ++;
    //                 console.log("遍历中left",left);
    //             };
    //         }
    //     }
    //     return all;
    // };


    /**给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。
     * 使用正负号作为标记---空间复杂度O（n）
    */
    // var findDuplicates = function(nums) {
    //     const n = nums.length;
    //     const ans = [];
    //     for (let i = 0; i < n; ++i) {
    //         const x = Math.abs(nums[i]);
    //         if (nums[x - 1] > 0) {
    //             nums[x - 1] = -nums[x - 1];
    //         } else {
    //             ans.push(x);
    //         }
    //     }
    //     return ans;
    // }


    /**给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
     *
    */

    //自己
    // var sortColors = function(nums) {
    //     let len = nums.length;
    //     for(let i = len; i > 0 ; i--){
    //         let left = 0;
    //         let right = 1;
    //         while(right < i){
    //             if(nums[left] > nums[right]){
    //                 let temp = nums[left];
    //                 nums[left] = nums[right];
    //                 nums[right] = temp;
    //             }
    //             left++;
    //             right++;
    //         }
    //     }
    //     return nums;
    // };
    /**由范围 [0,n] 内所有整数组成的 n + 1 个整数的排列序列可以表示为长度为 n 的字符串 s ，其中:
如果 perm[i] < perm[i + 1] ，那么 s[i] == 'I' 
如果 perm[i] > perm[i + 1] ，那么 s[i] == 'D' 
给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列perm，则返回其中 任何一个 。
。*/
    // var diStringMatch = function(s) {
    //     let perm = [];
    //     let len = s.length;
    //     let min = 0;
    //     let max = len;
    //     for(let i = 0;i < len ;i++){
    //         perm[i] = s[i] === "I" ? min++ : max--;
    //     }
    //     perm[len] = min;
    //     return perm;
    // };

    /**以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。*/
    // var merge = function(intervals) {
    //     intervals.sort((a,b)=>a[0]-b[0]);//以首字母先进行排序
    //     let result = [];
    //     let temp = intervals[0];
    //     let len = intervals.length;
    //     for(let i = 0;i<len;i++){
    //         let item = intervals[i];
    //         if(temp[1] >= item[0]){
    //             temp[1] = Math.max(temp[1],item[1]); //若有包含则取最大的右边界
    //         }else{
    //             //若没有交集则将上一个集合继续推送到结果中。
    //             result.push(temp);
    //             temp = item;
    //         }
    //     }
    //     result.push(temp);
    //     return result;
    // };

    /**给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。在「杨辉三角」中，每个数是它左上方和右上方的数的和。*/
    // var getRow = function(rowIndex) {
    //     let nowRow;
    //     if(rowIndex === 0){
    //         return [1]
    //     }else if(rowIndex === 1){
    //         return [1,1]
    //     }
    //     let tempArr = [1,1];
    //     for(let i = 2;i <= rowIndex;i++){
    //         nowRow = new Array(i+1).fill(1);
    //         for(let j = 1;j<i;j++){
    //             nowRow[j] = tempArr[j-1] + tempArr[j];
    //         }
    //         console.log(nowRow);
    //         tempArr = nowRow;
    //     }
    //     return nowRow;
    // };

    /**给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。*/
    // var rotate = function(matrix) {
    //     const n = matrix.length;
    //     for (let i = 0; i < Math.floor(n / 2); ++i) {
    //         for (let j = 0; j < Math.floor((n + 1) / 2); ++j) {
    //             const temp = matrix[i][j];
    //             matrix[i][j] = matrix[n - j - 1][i];
    //             matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
    //             matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
    //             matrix[j][n - i - 1] = temp;
    //         }
    //     }
    // };  

    // 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。
    // var generateMatrix = function(n) {
    //     let num = 1;
    //     const matrix = new Array(n).fill(0).map(()=>new Array(n).fill(0));//创造n*n的矩阵
    //     let top = 0 ,left = 0;
    //     let bottom = n-1,right = n-1;
    //     while(left<=right && top<=bottom){ //顶行遍历，从(top,left)到(top,right)（从左到右）
    //         for(let column = left;column<=right;column++){
    //             matrix[top][column] = num;
    //             console.log("行",num);
    //             num++;
    //         }
    //         for(let row = top+1;row<=bottom;row++){//右列遍历，从(top+1,right)到(bottom,right)（从上到下）
    //             matrix[row][right] = num;
    //             console.log("列",num);
    //             num++;
    //         }
    //         if(left < right && top < bottom){//出现这种情况时，避免重复遍历==>若是奇数，证明只有单行单列，若是偶数，则是遍历完毕
    //             for(let column = right-1;column>left;column--){//底行遍历，从(bottom,right-1)到(bottom,left+1)（从右到左）
    //                 matrix[bottom][column] = num;
    //                 num++;
    //             }
    //             for(let row = bottom;row>top;row--){//左列遍历，从(bottom,left)到(top+1,left)（从下到上）
    //                     matrix[row][left] = num;
    //                     num++;
    //                 }
    //         }
        
    //         left++;
    //         top++;
    //         bottom--;
    //         right--;
    //     }
    //     return matrix;
    // };

    /**编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：
    每行的元素从左到右升序排列。
    每列的元素从上到下升序排列。*/

    // var searchMatrix = function(matrix, target) {
    //     for (const row of matrix) {
    //         const index = search(row, target);
    //         if (index >= 0) {
    //             return true;
    //         }
    //     }
    //     return false;
    // };

    // const search = (nums, target) => {
    //     let low = 0, high = nums.length - 1;
    //     while (low <= high) {
    //         const mid = Math.floor((high - low) / 2) + low;
    //         const num = nums[mid];
    //         if (num === target) {
    //             return mid;
    //         } else if (num > target) {
    //             high = mid - 1;
    //         } else {
    //             low = mid + 1;
    //         }
    //     }
    //     return -1;
    // }

    /**
 * @param {string} first
 * @param {string} second
 * @return {boolean}
 */
/**字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。*/
// var oneEditAway = function(first, second) {
//     if(Math.abs(first.length - second.length) > 1) return false;
//     if(first.length ===0 || second.length === 0){
//         if(Math.abs(first.length - second.length) < 2) return true
//     }
//     let firstIndex = 0;
//     let secondIndex = 0;    
//     if(first.length ===second.length){
//         let different = 0
//         while((firstIndex<first.length) || (secondIndex<second.length)){
//             if(first[firstIndex]!==second[secondIndex]){
//                 different++;
//             }
//             if(different > 1) return false;
//             firstIndex++;
//             secondIndex++;
//         }
//     }else if(first.length > second.length){
//         while((firstIndex<first.length) || (secondIndex<second.length)){
//             if(first[firstIndex]!==second[secondIndex]){
//                 if(first[firstIndex+1]!==second[secondIndex]) return false;
//             }
//             firstIndex++;
//             secondIndex++;
//         }
//     }else{
//         let flag = 0;
//         while((firstIndex<first.length) || (secondIndex<second.length)){
//             if(first[firstIndex]!==second[secondIndex]){
//                 flag ++;
//                 secondIndex++;
//             }else{
//                 firstIndex++;
//                 secondIndex++;
//             }
//             if(flag >1) return false;
//         }
//     }
//     return true
// };
/**给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠。*/
    // leetcode执行超时 复杂度过高===>动态规划==>找到状态转移方程
    var eraseOverlapIntervals = function (intervals) {
        if (!intervals.length) {
            return 0;
        }

        intervals.sort((a, b) => a[0] - b[0]); //按左边界排序
        const n = intervals.length;
        const dp = new Array(n).fill(1); //初始化dp数组==>为什么都填充1。因为自身便就一个不重合区间

        for (let i = 1; i < n; i++) {//当前数组左边界，从1开始是因为第一个左边没有区间，只有自身
            for (let j = 0; j < i; j++) {//以当前区间为界限的右边界
                //循环i,j找出intervals中最多有多少个不重复的区间
                //j的右边界小于i的左边界 相当于多出了一个不重合区间
                if (intervals[j][1] <= intervals[i][0]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1); //更新dp[i]=====>表示前i个区间中最大不重合区间的个数;dp[j] + 1 将之前最大不重合区间的个数的也一块加上
                }
            }
        }
        console.log(dp);
        return n - Math.max(...dp); //n减去最多的不重复的区间===最少删除区间的个数
    };

    // 贪心算法
    // var eraseOverlapIntervals = function (intervals) {
    //     if (!intervals.length) {
    //         return 0;
    //     }

    //     //按右边界排序，然后从左往右遍历，右边界结束的越早，留给后面的区间的空间就越大，不重合的区间个数就越多
    //     intervals.sort((a, b) => a[1] - b[1]);

    //     const n = intervals.length;
    //     let right = intervals[0][1]; //right初始化为第一个区间的右边界
    //     let ans = 1; //最多的不重合区间的个数
    //     for (let i = 1; i < n; ++i) {
    //         //循环区间数组
    //         if (intervals[i][0] >= right) {
    //             //当区间的左边界大于上一个区间的右边界的时候 说明是一对不重合区间
    //             ++ans; //ans加1
    //             right = intervals[i][1]; //更新right
    //         }
    //     }
    //     return n - ans; //intervals的长度减去最多的不重复的区间 就是最少删除区间的个数
    // };
    /**334 给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。
     * 如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 。
     * 双向遍历*/
    // var increasingTriplet = function(nums) {
    //     const len = nums.length;
    //     if(len < 3) return false;
    //     let leftMin = Array(len).fill(0);
    //     leftMin[0] = nums[0];
    //     let rightMax = Array(len).fill(0);
    //     rightMax[len-1] = nums[len-1]
    //     for(let i = 1;i<len;i++){
    //         leftMin[i] = Math.min(leftMin[i-1],nums[i]);
    //     }
    //     for(let i = len - 2;i>=0;i--){
    //         rightMax[i] = Math.max(rightMax[i+1],nums[i]);
    //     }
    //     console.log(leftMin);
    //     console.log(rightMax);
    //     for(let i = 1;i<len;i++){
    //         if(nums[i] > leftMin[i] && nums[i] < rightMax[i])return true
    //     }
    //     return false
    // };
    //贪心算法==>为了找到递增的三元子序列，first 和 second 应该尽可能地小，此时找到递增的三元子序列的可能性更大。
    // var increasingTriplet = function(nums) {
    //     const n = nums.length;
    //     if (n < 3) {
    //         return false;
    //     }
    //     let first = nums[0], second = Number.MAX_VALUE;
    //     for (let i = 1; i < n; i++) {
    //         const num = nums[i];
    //         if (num > second) {
    //             return true;
    //         } else if (num > first) {
    //             second = num;
    //         } else {
    //             first = num;
    //         }
    //     }
    //     return false;
    // };

    /**给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。
    题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。*/
    // var productExceptSelf = function(nums) {
    //     let len = nums.length;
    //     let leftSum = Array(len);
    //     leftSum[0] = 1;
    //     let rightSum = Array(len);
    //     rightSum[len - 1] = 1
    //     for(let i = 1;i<len;i++){
    //         leftSum[i] = leftSum[i - 1] * nums[i - 1];
    //     }
    //     for(let i = len -2 ;i>=0;i--){
    //         rightSum[i] = rightSum[i + 1] * nums[i + 1];
    //     }
    //     for(let i = 0;i<len;i++){
    //         leftSum[i] =rightSum[i] * leftSum[i];
    //     }
    //     return leftSum;
    // };

    /**设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。如果指定节点没有对应的“下一个”节点，则返回null。*/
        //     var inorderSuccessor = function(root, p) {
        //     const stack = [];
        //     let prev = null;
        //     let curr = root;
        //     while(stack.length || curr){
        //         //这里是遍历到当前节点左子树最低端
        //         while(curr){
        //             stack.push(curr);
        //             curr = curr.left;
        //         } 
        //         // 返回到当前子节点
        //         curr = stack.pop();
        //         // 判断上一个访问节点是否为节点p
        //         if(prev === p){
        //             return curr;
        //         }
        //         //用当前子节点替换上一个访问节点
        //         prev = curr;
        //         //查询当前节点的右子树
        //         curr = curr.right;
        //     }
        //     return null;
        // };
    
    
    init();
    function init(){
        var nums =  [1,2,3,4];
        param_1 = productExceptSelf(nums);
        console.log(param_1);
    }


    </script>
</body>
</html>
