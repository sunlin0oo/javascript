<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。列表中的每个元素只可能是整数或整数嵌套列表*/
        // var deserialize = function(s) {
        //     let index = 0;
        //     const dfs = (s) => {
        //         if (s[index] === '[') {
        //             index++;
        //             const ni = new NestedInteger();
        //             while (s[index] !== ']') {
        //                 ni.add(dfs(s));
        //                 if (s[index] === ',') {
        //                     index++;
        //                 }
        //             }
        //             index++;
        //             return ni;
        //         } else {
        //             let negative = false;
        //             if (s[index] === '-') {
        //                 negative = true;
        //                 index++;
        //             }
        //             let num = 0;
        //             while (index < s.length && isDigit(s[index])) {
        //             //charCodeAt() 方法可返回指定位置的字符的 Unicode 编码
        //                 num = num * 10 + s[index].charCodeAt() - '0'.charCodeAt();
        //                 index++;
        //             }
        //             if (negative) {
        //                 num *= -1;
        //             }
        //             return new NestedInteger(num);
        //         }
        //     }
        //     return dfs(s);
        // };

        // const isDigit = (ch) => {
        //     //parseFloat(ch)该函数指定字符串中的首个字符是否是数字--->如果字符串的第一个字符不能被转换为数字，那么 parseFloat() 会返回 NaN。
        //     return parseFloat(ch).toString() === "NaN" ? false : true;
        // }


        /*给定一个整数 n ，返回 *可表示为两个 `n` 位整数乘积的 **最大回文整数*** 。因为答案可能非常大，所以返回它对 `1337` **取余** 。*/
        // var largestPalindrome = function(n) {
        //     if(n === 1){
        //         return 9
        //     };
        //     let max = 10**n - 1;
        //     for(let left = max ; left>max/10; left--){
        //         let right = String(left).split('').reverse().join('');
        //         let p = BigInt(String(left)+right);
        //         let x = BigInt(max);
        //         while((x*x)>=p){
        //             if(p % x === BigInt(0)){
        //                 return p % BigInt(1337);
        //             }
        //             x--;
        //         }
        //     }
        // };


        // const isletter= (i)=>{
        //     return(i >= "a" && i<="z") || (i >= "A" && i<="Z");
        // }

        // var mostCommonWord = function(paragraph, banned) {
        //     const bannedSet = new Set();
        //     //将禁用单词放入Set集合中
        //     for (const word of banned) {
        //         bannedSet.add(word);
        //     }

        //     let maxFrequency = 0;//记录当前最大次序
        //     const frequencies = new Map();//建立HashMap
        //     let sb = '';
        //     const length = paragraph.length;//不计算分号
        //     for(let i = 0;i <= length;i++){
        //         if(i<length && isletter(paragraph[i])){
        //             sb = sb + paragraph[i].toLowerCase();//拼接单词
        //         }else if(sb.length >0){//判断之前的单词是否拼接，避免""," 和 " "连续出现情况
        //             if(!bannedSet.has(sb)){ //一个单词判断是否为禁用单词
        //                 let frequency = (frequencies.get(sb) || 0) + 1;//哈希表加入，若没有则输入，有的话则value+1,
        //                 frequencies.set(sb, frequency);//重新计数，加入哈希表中
        //                 maxFrequency = Math.max(maxFrequency,frequency);//求出当前最多的选中次序
        //             }
        //             sb = '';//重置单词
        //         }
        //     }
        //     let  mostCommon = '';
        //     // entries() 返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。
        //     for (const [word,frequency] of frequencies.entries()){
        //         if (frequency === maxFrequency) { //与之前的最多选中进行匹配key
        //             mostCommon = word;
        //             break;
        //         }
        //     }
        //     console.log(mostCommon);
        //     return  mostCommon;
        // };

        /*给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标   */
        // var twoSum = function(nums, target) {
        //     let map = new Map();
        //     for(let i = 0,len = nums.length;i<len ; i++){
        //         if(map.has(target - nums[i])){
        //             return [map.get(target - nums[i]),i]
        //         }else{
        //             map.set(nums[i],i);
        //         }
        //     }
        //     return null;
        // };

        /*给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
        请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。*/

        // var merge = function(nums1, m, nums2, n) {
        //     let p1=0,p2=0;
        //     let sort =new Array(m+n).fill(0);
        //     var cur;
        //     while(p1 < m || p2 <n){
        //         if(p1 === m){
        //             cur = nums2[p2];
        //             p2++;
        //         }else if(p2 === n){
        //             cur = nums1[p1];
        //             p1++;
        //         }else if(nums1[p1]<=nums2[p2]){
        //             cur = nums1[p1];
        //             p1++;
        //         }else {
        //             cur = nums2[p2];
        //             p2++;
        //         }
        //         sort[p1 + p2 - 1] = cur;
        //     }
        //     for(let i = 0 ; i<m+n;i++){
        //         nums1[i] = sort[i];
        //     }
        // };

        /*给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。
        返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。*/

        // var intersect = function(nums1, nums2) {
        //     let intersectArray = new Map();
        //     let arr1 = [];
        //     let len1 =nums1.length,len2 =nums2.length;
        //     for(let i = 0;i<len1;i++){
        //         if(!intersectArray.get(nums1[i])){
        //             intersectArray.set(nums1[i],1)
        //         }else{
        //             let nums = intersectArray.get(nums1[i]) + 1;
        //             intersectArray.set(nums1[i],nums);
        //         }
        //     }
        //     for(let i = 0;i < len2;i++){
        //         if(intersectArray.get(nums2[i])>0){
        //             let nums = intersectArray.get(nums2[i]) - 1;
        //             intersectArray.set(nums2[i],nums);
        //             arr1.push(nums2[i]);
        //         }
        //     }
        //     return arr1;
        // };

        /*给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
        你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
         返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
         */

        // var maxProfit = function(prices) {
        //     let minprice = prices[0], maxmoney = -prices[0];
        //     let index = 0
        //     for(let i = 0,len = prices.length;i<len;i++){
        //         if(prices[i] - minprice > maxmoney){
        //             maxmoney = prices[i] - minprice;
        //             index = i+1;
        //         };
        //         if(prices[i] < minprice){
        //             minprice = prices[i];
        //         };
        //     };
        //     if(maxmoney<=0){
        //         return 0;
        //     }
        //     return maxmoney;
        // };


        /**在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。
            给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。
            重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。
            如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。*/

        // var matrixReshape = function(mat, r, c) {
        //     let m = mat.length;
        //     let n = mat[0].length;
        //     if((m * n) !== (r*c)) return mat;
        //     let reshapeArr = [];
        //     let arr =[];
        //     arr = mat.flat(1);
        //     let index = 0
        //     for(let i = 0;i<r;i++){
        //         let arr1 = []
        //         for(let j=0;j<c;j++){
        //             arr1.push(arr[index]);
        //             index++;
        //         }
        //         reshapeArr.push(arr1);
        //     }
        //     return reshapeArr;
        // };


        /**给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。在「杨辉三角」中，每个数是它左上方和右上方的数的和。*/
        // var generate = function(numRows) {
        //     let all = [];
        //     for(let i = 0;i<numRows;i++){
        //         let nowRow = new Array(i+1).fill(1);
        //         for(let j = 1 ;j < nowRow.length-1;j++){
        //             nowRow[j] = all[i-1][j-1] + all[i-1][j];
        //         }
        //         all.push(nowRow);
        //     }
        //     return all;
        // };

        /**给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。
         * 返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。
         * 两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。
         *
        */

        // var shortestToChar = function(s, c) {
        //     console.log(subboxes);
        //     let arr = Array.from(s);
        //     let answer = [];
        //     let answerIndex = [];
        //     for(let i = 0,len = arr.length;i<len;i++){
        //         if(arr[i] === c){
        //             answerIndex.push(i);
        //         }
        //     }
        //     for(let i = 0,len = answerIndex.length;i<len;i++){
        //         for(let j = 0,len = answerIndex[i] ;j<=len;j++){
        //             if(answerIndex[i-1] === undefined){
        //                 answer.push( Math.abs(answerIndex[i] - j));
        //             }else if(j >answerIndex[i-1]){
        //                 answer.push(Math.min( Math.abs(answerIndex[i] - j),Math.abs(answerIndex[i-1] - j)));
        //             }
        //             else{
        //                 continue;
        //             }
        //         }
        //     }
        //     if(answerIndex[answerIndex.length-1] < arr.length){
        //         for(let i = answerIndex[answerIndex.length-1]+1,len = arr.length;i<len;i++){
        //             answer.push( Math.abs(answerIndex[answerIndex.length-1] - i));
        //         }
        //     }
        //     return answer;
        // };

        /**请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
        数字 1-9 在每一行只能出现一次。
        数字 1-9 在每一列只能出现一次。
        数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。----->可以采用坐标的方法
        */


        // var isValidSudoku = function(board) {
        //     for(let i = 0;i<9;i++){
        //         let map1 = new Map();
        //         let map2 = new Map();
        //         for(let j = 0;j<9;j++){
        //             if(board[i][j]!=='.'){
        //                 if(map1.has(board[i][j])) return false;
        //                 map1.set(board[i][j],[i][j]);
        //             };
        //             if(board[j][i]!=='.'){
        //                 if(map2.has(board[j][i])) return false;
        //                 map2.set(board[j][i],[j][i]);
        //             };
        //         };
        //     };
        //     for(let i = 0;i<9;i+=3){
        //         let map3 = new Map();
        //         for(let j = 0;j<9;j++){
        //             if(Math.floor(j%3) === 0){
        //                 map3 = new Map();
        //             };
        //             if(board[i][j]!=='.'){
        //                 if(map3.has(board[i][j])) return false;
        //                 map3.set(board[i][j]);
        //             }
        //             if(board[i+1][j]!=='.'){
        //                 if(map3.has(board[i+1][j])) return false;
        //                 map3.set(board[i+1][j]);
        //             }
        //             if(board[i+2][j]!=='.'){
        //                 if(map3.has(board[i+2][j])) return false;
        //                 map3.set(board[i+2][j]);
        //             }
        //         }
        //     };
        //     return true;
        // };

        // var isValidSudoku = function(board) {
        //     const rows = new Array(9).fill(0).map(() => new Array(9).fill(0));
        //     const columns = new Array(9).fill(0).map(() => new Array(9).fill(0));
        //     const subboxes = new Array(3).fill(0).map(() => new Array(3).fill(0).map(() => new Array(9).fill(0)));
        //     for (let i = 0; i < 9; i++) {
        //         for (let j = 0; j < 9; j++) {
        //             const c = board[i][j];
        //             if (c !== '.') {
        //c.charCodeAt() - '0'.charCodeAt() ===Number(c)  ===> s[i]的unicode编码，减去0的unicode编码，来获取s[i]的数字s
        //                 const index = c.charCodeAt() - '0'.charCodeAt() - 1;
        //                 rows[i][index]++;
        //                 columns[j][index]++;
        //                 subboxes[Math.floor(i / 3)][Math.floor(j / 3)][index]++;
        //                 if (rows[i][index] > 1 || columns[j][index] > 1 || subboxes[Math.floor(i / 3)][Math.floor(j / 3)][index] > 1) {
        //                     return false;
        //                 }
        //             }
        //         }
        //     }
        //     return true;
        // };

        //给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
        // var setZeroes = function(matrix) {
        //     let row = new Map();
        //     let column = new Map();
        //     for(let i = 0,len = matrix.length;i<len;i++){
        //         for(let j = 0,len = matrix[i].length;j<len;j++){
        //             if(matrix[i][j] === 0){
        //                 if(!row.has[i])
        //                 row.set([i],0);
        //                 if(!column.has[j])
        //                 column.set([j],0);
        //             }
        //         }
        //     }
        //     console.log(row,column);
        //     for(let rows of row.keys()){
        //         for(let j = 0,len = matrix[rows].length;j<len;j++){
        //             matrix[rows][j] = 0;
        //         }
        //     }
        //     for(let i = 0,len = matrix.length;i<len;i++){
        //         for(let columns of column.keys()){
        //                 matrix[i][columns] = 0;
        //             }
        //         }

        //     return matrix
        // };

        // var setZeroes = function(matrix) {
        //     const m = matrix.length, n = matrix[0].length;
        //     const row = new Array(m).fill(false);
        //     const col = new Array(n).fill(false);
        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (matrix[i][j] === 0) {
        //                 row[i] = col[j] = true;
        //             }
        //         }
        //     }
        //     for (let i = 0; i < m; i++) {
        //         for (let j = 0; j < n; j++) {
        //             if (row[i] || col[j]) {
        //                 matrix[i][j] = 0;
        //             }
        //         }
        //     }
        // };

            /**
             * 给你一个由若干单词组成的句子sentence ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。
             * 请你将句子转换为 “山羊拉丁文（Goat Latin）”（一种类似于 猪拉丁文- Pig Latin 的虚构语言）。山羊拉丁文的规则如下：
             * 如果单词以元音开头（'a', 'e', 'i', 'o', 'u'），在单词后添加"ma"。
             * 例如，单词 "apple" 变为 "applema" 。
             * 如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加"ma"。
             * 例如，单词 "goat" 变为 "oatgma" 。
             * 根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从 1 开始。
             * 例如，在第一个单词后添加 "a" ，在第二个单词后添加 "aa" ，以此类推。
             * 返回将 sentence 转换为山羊拉丁文后的句子。
        */

        // var toGoatLatin = function(sentence) {
        //         const vowels = new Set();
        //         vowels.add('a');
        //         vowels.add('e');
        //         vowels.add('i');
        //         vowels.add('o');
        //         vowels.add('u');
        //         vowels.add('A');
        //         vowels.add('E');
        //         vowels.add('I');
        //         vowels.add('O');
        //         vowels.add('U');

        //         const n = sentence.length;
        //         let i = 0, cnt = 1;
        //         ans = '';

        //         while (i < n) {
        //             let j = i;
        //             while (j < n && sentence[j] !== ' ') {
        //                 ++j;
        //             }

        //             ++cnt;
        //             if (cnt !== 2) {
        //                 ans += ' ';
        //             }
        //             if (vowels.has(sentence[i])) {
        //                 ans += sentence.substring(i, j);
        //             } else {
        //                 ans += sentence.slice(i + 1, j);
        //                 ans += sentence[i];
        //             }
        //             ans += 'm';
        //             for (let k = 0; k < cnt; ++k) {
        //                 ans += 'a';
        //             }

        //             i = j + 1;
        //         }

        //         return ans;
        //     };
        /**
         * 给定一个长度为 n 的整数数组 nums 。
            假设 arrk 是数组 nums 顺时针旋转 k 个位置后的数组，我们定义 nums 的 旋转函数  F 为：
            F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]
            返回 F(0), F(1), ..., F(n-1)中的最大值 。
            生成的测试用例让答案符合 32 位 整数。

        */

        // var maxRotateFunction = function(nums) {
        //     let numSum = 0;
        //     let maxSum = 0;
        //     let temp;
        //     let len = nums.length;
        //     for(let i = 0;i<len;i++){
        //     numSum +=nums[i];
        //     }
        //     for(let i = 0;i<len;i++){
        //     maxSum += nums[i] * i;
        //     }
        //     temp = maxSum;
        //     for(let i = nums.length - 1;i>0;i--){
        //         temp = temp + numSum - len * nums[i];
        //         maxSum = Math.max(temp,maxSum);
        //     }
        //     return maxSum;
        // };

        //给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。
        // var firstUniqChar = function(s) {
        //     let map = new Map();
        //     let arr = Array.from(s);
        //     let temp = Infinity;
        //     for(let i = 0, len = arr.length;i < len ; i++){
        //         if(map.has(arr[i])){
        //             map.set(arr[i],-1);
        //         }else{
        //             map.set(arr[i],i);
        //         }
        //     }
        //     for(let value of map.values()){
        //         if(value !== -1) temp = Math.min(value,temp);
        //     }
        //     if(temp === Infinity){
        //     return -1;
        //     }else{
        //         return temp;
        //     }
        // };

        // var firstUniqChar = function(s) {
        //     /*_.countBy(collection, [iteratee=_.identity])：
        //     _.countBy方法创建一个由键组成的对象，这些键是通过运行iteratee的collection的每个元素的结果生成的。每个 key 的对应值是iteratee返回 key 的次数。
        //     */
        //     const frequency = _.countBy(s);//安装库lodash才能使用
        //     console.log(frequency);
        //     for (const [i, ch] of Array.from(s).entries()) {
        //         if (frequency[ch] === 1) {
        //             return i;
        //         }
        //     }
        //     return -1;
        // };

        /**给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。*/

        // var isAnagram = function(s, t) {
        //     if (s.length !== t.length) {
        //         return false;
        //     }
        //     const table = new Array(26).fill(0);
        //     for (let i = 0; i < s.length; ++i) {
        //         /**ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。
        //          * 'a'.codePointAt(0)
        //         */
        //         console.log("'a'.codePointAt(0)::",'a'.codePointAt(0))//97
        //         table[s.codePointAt(i) - 'a'.codePointAt(0)]++;
        //     }
        //     for (let i = 0; i < t.length; ++i) {
        //         table[t.codePointAt(i) - 'a'.codePointAt(0)]--;
        //         if (table[t.codePointAt(i) - 'a'.codePointAt(0)] < 0) {
        //             return false;
        //         }
        //     }
        //     return true;
        // };

        
        /**给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。
         * 如果可以，返回 true ；否则返回 false 。magazine 中的每个字符只能在 ransomNote 中使用一次。*/
        // var canConstruct = function(ransomNote, magazine) {
        //     const table = new Array(26).fill(0);
        //     for(let i = 0,len = ransomNote.length;i<len ;i++){
        //         table[ransomNote.codePointAt(i)-'a'.codePointAt(0)]++
        //     }
        //     for(let i = 0,len = magazine.length;i<len ;i++){
        //         if(table[magazine.codePointAt(i)-'a'.codePointAt(0)] === 0){
        //             continue;
        //         }else{
        //             table[magazine.codePointAt(i)-'a'.codePointAt(0)]--;
        //         }
        //     }
        //     for(let i = 0,len = table.length;i<len ; i++){
        //         if(table[i]>0) return false;
        //     }
        //     return true;
        // };

        /**给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。
        如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，"1001" 中的两个 1 的距离为 3 。*/

        // var binaryGap = function(n) {
        //     let number = Array.from(n.toString(2));
        //     console.log(number);
        //     let firstIndex,secondIndex;
        //     for(let i = 0,len = number.length;i<len;i++){
        //         if(number[i] === '1'){
        //         firstIndex = i;
        //         break;
        //         }
        //     }
        //     for(let i = firstIndex+1,len = number.length;i<len;i++){
        //         if(number[i] === '1'){
        //             secondIndex = i;
        //             break;
        //         }
        //     }
        //     if(secondIndex === undefined) return 0;

        //     let absLength;
        //     let maxLength  = secondIndex -firstIndex ;

        //     for(let i = secondIndex+1,len = number.length;i<len;i++){
        //         if(number[i] === '1'){
        //             firstIndex = secondIndex;
        //             secondIndex = i;
        //             absLength = secondIndex - firstIndex;
        //             maxLength = Math.max(maxLength,absLength);
        //         }
        //     }
        //     return maxLength;
        // };

        // 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
        // var mergeTwoLists = function(l1, l2) {
        //     if (l1 === null) {
        //         console.log(l2);
        //         return l2;
        //     } else if (l2 === null) {
        //         console.log(l1);
        //         return l1;
        //     } else if (l1.val < l2.val) { //l1当前值大于l2当前值      
        //         l1.next = mergeTwoLists(l1.next, l2);
        //         console.log(l1);
        //         return l1;
        //     } else {
        //         l2.next = mergeTwoLists(l1, l2.next);
        //         console.log(l2);
        //         return l2;
        //     }
        // };


        /**给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。*/
        // var Solution = function(nums) {
        //     this.pos = new Map();
        //     for(let i = 0,len = nums.length;i<len;i++){
        //         if(!this.pos.has(nums[i])) this.pos.set(nums[i],[]);
        //         this.pos.get(nums[i]).push(i);
        //     }
        // };

        // Solution.prototype.pick = function(target) {
        //     const indeies = this.pos.get(target);
        //     return indeies[Math.floor(Math.random() * indeies .length)];
        // };
        
        /**给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。*/
        // function ListNode(val, next) {
        //     this.val = (val===undefined ? 0 : val)
        //     this.next = (next===undefined ? null : next)
        // }

        // var removeElements = function(head, val) {
        //     if(head === null){
        //         return head;
        //     }
        //     head.next = removeElements(head.next,val);
        //     return head.val === val? head.next : head;
        // };

        /**给你一个可能含有 重复元素 的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组中。实现 Solution 类：
            Solution(int[] nums) 用数组 nums 初始化对象。
            int pick(int target) 从 nums 中选出一个满足 nums[i] == target 的随机索引 i 。如果存在多个有效的索引，则每个索引的返回概率应当相等。*/
        /**
         * @param {number[]} nums
         */
        // var Solution = function(nums) {
        //     this.pos = new Map();
        //     for(let i = 0,len = nums.length;i<len;i++){
        //         if(!this.pos.has(nums[i])) this.pos.set(nums[i],[]);
        //         this.pos.get(nums[i]).push(i);
        //     }
        // };

        // /** 
        //  * @param {number} target
        //  * @return {number}
        //  */
        // Solution.prototype.pick = function(target) {
        //     const indeies = this.pos.get(target);
        //     return indeies[Math.floor(Math.random() * indeies .length)];
        // };

        // /**
        //  * Your Solution object will be instantiated and called as such:
        //  * var obj = new Solution(nums)
        //  * var param_1 = obj.pick(target)
        //  */


        /**给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。*/
        // var reverseList = function(head) {
        //     let curr = head;
        //     let prev = null;
        //     while(curr){
        //         let next = curr.next;
        //         curr.next = prev;
        //         prev = curr;
        //         curr = next;
        //     }
        //     return prev;
        // };
        /**给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 */
        // var deleteDuplicates = function(head) {
        //     if(!head) return head;
        //     let curr = head;
        //     console.log(curr);
        //     while(curr.next){
        //         if(curr.val === curr.next.val){
        //             curr.next = curr.next.next;
        //         }else{
        //             curr = curr.next;
        //         }
        //         console.log(head);
        //     }
        //     return head;
        // };


        // 给你一个整数数组 nums，将 nums 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。==>优化方法：原地交换/双指针+一次遍历
        // var sortArrayByParity = function(nums) {
        //     // nums.sort((a,b)=>a-b);
        //     let array1 = [];
        //     let array2 = [];
        //     for(let i = 0,len = nums.length; i < len ;i++){
        //         if(nums[i] % 2 !==0){
        //         array1.push(nums[i])
        //         }else{
        //             array2.push(nums[i])
        //         }
        //     }
        //     array2.push.apply(array2,array1);
        //     return array2
        // };

      /**给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
        有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。*/

        var isValid = function(s) {
            const n = s.length;
            if(n%2 === 1){
                return false
            }
            const pairs = new Map([
                [')', '('],
                [']', '['],
                ['}', '{']
            ]);
            const stk = [];
            for(let ch of s){
                if(pairs.has(ch)){
                    if(!stk.length || stk[stk.length-1] !== pairs.get(ch)){
                        return false;
                    }
                    stk.pop();
                }else{
                    stk.push(ch);
                };
            };
            return !stk.length;
        };
        init();
        function init(){
            let head = [1,2,6,3,4,5,6], val = 6;
            let arr = removeElements(head, val);
            console.log(arr);
        }


    </script>
</body>
</html>
