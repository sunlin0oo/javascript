<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        //ES6
        class Box1{
            constructor(a){
                // this.a=a;
                // console.log(a);
            }
            play(){
                console.log(this.a,"---play");
            }
        }

        class Ball1 extends Box1{
            constructor(a){
                super(a)
            }
        }
// 将Box1放到Ball1原型链下
        var a=new Box1();
        var b=new Ball1();
        console.log(a)
        console.log(b);

// -----------------------------------

        function Box(a){
            this.a=a;
            console.log(a);
        }

        Box.prototype.play=function(){
            // console.log("play");
            console.log(this.a,"---play");
        }



        // var b=new Box(3);
        // b.play();


        // 寄生式继承
        // function Ball(a){
        // 相当于super()
        //若直接执行的话Box(a),这里的this是window(属于回调),通过apply改变this 
        //     Box.apply(this,arguments);
        // }

        // 将Box的原型寄生到函数F上，new F()只执行F不执行Box
        // function F(){

        // }
      
        // F.prototype=Box.prototype;
        // Ball.prototype=new F();
        

        // 原型继承
        // Ball.prototype = new Box();
        // var c=new Ball(1);
        // // c.__proto__=new Box();
        // console.log(c)
        


        Function.prototype.extends=function(superClass){
            // this  继承的子类
            //  F类
            function F(){}
            // 寄生，中间载体
            F.prototype=superClass.prototype;
            // 父类没有construcor,重现添加上
            if(superClass.prototype.constructor!==superClass){
                Object.defineProperty(superClass.prototype,"constructor",{
                    value:superClass
                })
            }
            // 先保存Ball原有的原型
            var proto=this.prototype;
            this.prototype=new F();
            // 返回所有自有属性key，不管是否可枚举，但不包括继承自原型的属性==>数组
            var names=Reflect.ownKeys(proto);
            for(var i=0;i<names.length;i++){
                var desc=Object.getOwnPropertyDescriptor(proto,names[i]);
                Object.defineProperty(this.prototype,names[i],desc);
            }
            this.prototype.super=function(arguments){
                // 这里的this就是Ball
                superClass.apply(this,arguments);
            }
            // 将superClass方法附在原型supers上
            this.prototype.supers=superClass.prototype;
        }



        function Ball(a){
            this.super(arguments);
        }
        Ball.prototype.run=function(){
            console.log("run")
        }
        // 重写
        Ball.prototype.play=function(){
            this.supers.play.apply(this,arguments)
            console.log("aaa")
        }

        Ball.extends(Box);
        var b=new Ball(5);
        b.play();
    </script>
</body>
</html>